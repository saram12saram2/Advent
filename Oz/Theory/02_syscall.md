Системный вызов (или сисколл, от английского "system call") — это механизм, который позволяет программам взаимодействовать с операционной системой. Когда программа хочет выполнить какую-либо операцию, требующую доступа к ресурсам системы (например, чтение или запись файла, выделение памяти, создание процесса и т.д.), она использует системный вызов.

### Как это работает:

1. **Запрос от программы**: Программа вызывает определённую функцию, которая соответствует системному вызову. Например, если программа хочет открыть файл, она может вызвать функцию `open()`.

2. **Переход в режим ядра**: При выполнении системного вызова происходит переключение из пользовательского режима (где работает программа) в режим ядра (где работает операционная система). Это необходимо для обеспечения безопасности и защиты ресурсов системы.

3. **Обработка вызова**: Операционная система обрабатывает запрос, выполняя необходимые действия (например, открывает файл, читает данные и т.д.).

4. **Возврат результата**: После завершения операции управление возвращается обратно в программу, и она получает результат выполнения системного вызова (например, дескриптор открытого файла или код ошибки).

### Примеры системных вызовов:

- **`read()`**: Чтение данных из файла.
- **`write()`**: Запись данных в файл.
- **`fork()`**: Создание нового процесса.
- **`exec()`**: Замена текущего процесса новым процессом.
- **`open()`**: Открытие файла.
- **`close()`**: Закрытие файла.

### Зачем нужны системные вызовы?

Системные вызовы необходимы для:

- **Безопасности**: Они обеспечивают контроль доступа к ресурсам системы, предотвращая несанкционированные действия со стороны программ.
- **Управления ресурсами**: Позволяют операционной системе управлять памятью, процессами, файлами и другими ресурсами.
- **Абстракции**: Системные вызовы предоставляют высокоуровневый интерфейс для работы с низкоуровневыми ресурсами, что упрощает разработку программ.

Таким образом, системные вызовы являются важной частью взаимодействия между приложениями и операционной системой, обеспечивая выполнение необходимых операций и управление ресурсами.


### Что происходит во время вызова системного вызова (сисколла)?

Когда программа вызывает системный вызов, происходит несколько ключевых шагов:

1. **Подготовка аргументов**: Программа подготавливает аргументы, которые будут переданы в системный вызов. Это может включать указатели на данные, идентификаторы файлов и другие параметры.

2. **Переключение в режим ядра**: Программа выполняет специальную инструкцию (например, `int 0x80` в Linux или `syscall`), которая инициирует переключение из пользовательского режима в режим ядра. Это необходимо для обеспечения безопасности, так как операции, требующие доступа к системным ресурсам, должны выполняться под контролем операционной системы.

3. **Обработка вызова**: Операционная система получает управление и определяет, какой именно системный вызов был запрошен. Она использует таблицу системных вызовов для нахождения соответствующей функции обработки.

4. **Выполнение операции**: Операционная система выполняет запрашиваемую операцию, например, читает данные из файла или создает новый процесс.

5. **Возврат результата**: После завершения операции управление возвращается в пользовательский режим, и программа получает результат выполнения системного вызова (например, код ошибки или дескриптор файла).

6. **Обработка ошибок**: Если произошла ошибка, программа может получить код ошибки и обработать его соответствующим образом.

### Что делает системный вызов `fork`?

Системный вызов `fork` используется для создания нового процесса. Когда программа вызывает `fork`, происходит следующее:

1. **Создание дочернего процесса**: Операционная система создает новый процесс, который является копией текущего (родительского) процесса. Этот новый процесс называется дочерним.

2. **Копирование контекста**: Все данные, включая память, регистры и открытые файлы, копируются из родительского процесса в дочерний. Однако оба процесса будут иметь разные идентификаторы процесса (PID).

3. **Возврат значений**: 
   - В родительском процессе `fork` возвращает PID дочернего процесса.
   - В дочернем процессе `fork` возвращает 0.
   - Если произошла ошибка, возвращается -1.

Таким образом, `fork` позволяет программе создавать новые процессы, что является основой для многозадачности в Unix-подобных системах.

### Что делает системный вызов `epoll`?

Системный вызов `epoll` используется для управления множеством файловых дескрипторов, что позволяет эффективно обрабатывать события ввода-вывода (I/O) в асинхронных приложениях. Он особенно полезен для серверов, которые должны обрабатывать множество соединений одновременно.

1. **Создание epoll-инстанса**: Сначала вызывается `epoll_create`, который создает объект epoll и возвращает его дескриптор. Этот объект будет использоваться для отслеживания событий.

2. **Добавление файловых дескрипторов**: С помощью `epoll_ctl` можно добавлять, удалять или изменять файловые дескрипторы, которые будут отслеживаться. Например, можно добавить сокет, чтобы отслеживать, когда на него приходят данные.

3. **Ожидание событий**: С помощью `epoll_wait` программа может блокироваться и ожидать, пока не произойдут события на одном или нескольких отслеживаемых дескрипторах. Когда событие происходит (например, данные поступают на сокет), `epoll_wait` возвращает информацию о том, какие дескрипторы готовы для чтения или записи.

Таким образом, `epoll` позволяет эффективно управлять большим количеством соединений и событий, что делает его популярным выбором для высокопроизводительных сетевых приложений.