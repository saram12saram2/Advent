### **Хеш-таблица: устройство и работа**

**Хеш-таблица** — это структура данных, которая позволяет эффективно хранить и искать пары "ключ-значение". Основной принцип работы:
1. **Хеш-функция** преобразует ключ в индекс массива.
2. **Данные** сохраняются в массиве по индексу, рассчитанному хеш-функцией.

---

### **2. Коллизии**

Коллизия происходит, когда два разных ключа имеют одинаковый индекс.

#### **Методы решения коллизий:**

1. **Метод цепочек (Chaining):**
   - Каждый элемент массива хранит список (например, связанный список) всех ключей, которые попали в этот индекс.
   - При вставке:
     - Если ключи конфликтуют, новый элемент добавляется в список.
   - Пример:
     ```go
     // Пример цепочек
     type HashTable struct {
         buckets [][]KeyValue
     }

     func (ht *HashTable) Put(key string, value string) {
         index := hash(key) % len(ht.buckets)
         ht.buckets[index] = append(ht.buckets[index], KeyValue{key, value})
     }
     ```

2. **Открытая адресация (Open Addressing):**
   - При конфликте ищется ближайшая свободная ячейка.
   - **Линейное пробирование**:
     - Пробуем ячейки одну за другой.
   - **Квадратичное пробирование**:
     - Пробуем ячейки с увеличивающимися шагами (1, 4, 9...).
   - **Двойное хеширование**:
     - Используем вторую хеш-функцию для определения следующего индекса.

---

### **3. Рехешинг**

**Рехешинг** — это процесс перераспределения данных при увеличении размера массива.

#### **Когда делать рехешинг?**
- Когда коэффициент заполнения (load factor) превышает определённое значение.
  - **Коэффициент заполнения**:
    ```go
    loadFactor = numberOfElements / len(array)
    ```
  - Обычно рехешинг инициируется при `loadFactor > 0.75`.



#### **Плавный рехешинг:**
- Вместо рехешинга всех элементов сразу перераспределяйте элементы **постепенно**:
  - При каждой операции (`Put`, `Get`, `Delete`) перемещайте несколько элементов.
  - Это предотвращает скачки в производительности.


---

### **5. Примеры популярных хеш-функций**

| **Функция**  | **Хорошо/Плохо**              | **Пример применения**                      |
|--------------|-------------------------------|--------------------------------------------|
| **CRC32**    | Хорошо для маленьких данных.  | Проверка целостности данных.               |
| **MD5**      | Устарела, небезопасна.        | Подходит для хеш-таблиц (не для криптографии). |
| **SHA-1**    | Устарела для безопасности.    | Иногда используется в незащищённых системах. |
| **SHA-256**  | Хорошо, но медленно.          | Криптография и безопасные хеш-таблицы.     |
| **FNV**      | Быстрая и хорошая для строк.  | Подходит для хеш-таблиц в Go.              |
| **AES**      | Неподходящая для общего хеширования. | Используется в криптографии, не для таблиц. |


---

### **7. Итог**

- **Коллизии:** решаются через цепочки или открытую адресацию.
- **Хеш-функции:** выбирайте быстрые и с равномерным распределением.
- **Рехешинг:** выполняйте при превышении коэффициента загрузки.
- **Хорошие хеш-функции:** CRC32, SHA-256, FNV (для строк). 

---



В приведённом коде реализованы две функции, связанные с хеш-таблицей: **`simpleHash`** (хеш-функция) и **`rehash`** (процесс рехешинга). Давайте разберём их подробно.

---

### **1. Функция `simpleHash`**

Эта функция используется для вычисления индекса в массиве (хеш-таблице) на основе строкового ключа.

#### **Как она работает:**
```go
func simpleHash(key string, size int) int {
    hash := 0
    for _, char := range key { // Проходим по каждому символу строки
        hash = (hash*31 + int(char)) % size // Обновляем значение хеша
    }
    return hash
}
```

1. **Инициализация:**
   - `hash := 0` — начальное значение хеша.

2. **Проход по каждому символу строки (`key`):**
   - В цикле `for _, char := range key` каждый символ строки обрабатывается.

3. **Формула:**
   ```go
   hash = (hash*31 + int(char)) % size
   ```
   - `hash*31`: каждый символ увеличивает значение хеша с учётом предыдущих символов (умножение на 31 помогает равномерно распределять значения).
   - `int(char)`: символ преобразуется в ASCII-код.
   - `% size`: приведение хеша к диапазону от `0` до `size-1` (длина массива хеш-таблицы).

4. **Результат:**
   - Возвращается индекс для ключа, который будет использоваться для вставки значения в массив.

---

### **Пример использования `simpleHash`**

```go
key := "hello"
size := 10
index := simpleHash(key, size)
fmt.Println("Index:", index)
```

- **Ключ**: `"hello"`.
- **Хеш**:
  - Для каждого символа:
    - `h = 104`, `e = 101`, `l = 108`, `l = 108`, `o = 111`.
  - Итоговое значение: индекс массива, где будет храниться ключ.

---

### **2. Функция `rehash`**

Эта функция выполняет **рехешинг**, который нужен при перераспределении элементов из одной таблицы (массив `oldBuckets`) в новую таблицу (`newBuckets`) большего размера.

#### **Как она работает:**
```go
func rehash(oldBuckets [][]KeyValue) [][]KeyValue {
    newSize := len(oldBuckets) * 2 // Увеличиваем размер массива в 2 раза
    newBuckets := make([][]KeyValue, newSize) // Создаём новый массив

    for _, bucket := range oldBuckets { // Проходим по всем "цепочкам" в старом массиве
        for _, kv := range bucket { // Проходим по каждому элементу "цепочки"
            index := hash(kv.Key) % newSize // Вычисляем новый индекс для ключа
            newBuckets[index] = append(newBuckets[index], kv) // Добавляем элемент в новую таблицу
        }
    }
    return newBuckets // Возвращаем новую таблицу
}
```

---

#### **Что делает эта функция:**

1. **Увеличение размера массива:**
   - Размер новой таблицы (`newSize`) равен удвоенному размеру старой.
   - Это уменьшает вероятность коллизий.

2. **Создание нового массива:**
   - `newBuckets := make([][]KeyValue, newSize)` создаёт массив с увеличенным размером, где каждая ячейка — это "цепочка".

3. **Перехеширование каждого элемента:**
   - Цикл `for _, bucket := range oldBuckets` проходит по каждой "цепочке" (списку элементов в одном индексе) старой таблицы.
   - Вложенный цикл `for _, kv := range bucket` проходит по каждому элементу этой цепочки.
   - Для каждого элемента:
     - Вычисляется новый индекс `index := hash(kv.Key) % newSize`.
     - Элемент добавляется в соответствующую ячейку новой таблицы.

4. **Возврат новой таблицы:**
   - После перераспределения всех элементов новая таблица возвращается.

---

### **Пример использования `rehash`**

```go
type KeyValue struct {
    Key   string
    Value string
}

func hash(key string) int {
    // Упрощённая версия хеш-функции для примера
    hash := 0
    for _, char := range key {
        hash = (hash*31 + int(char))
    }
    return hash
}

func main() {
    oldBuckets := make([][]KeyValue, 5)
    oldBuckets[0] = append(oldBuckets[0], KeyValue{Key: "key1", Value: "value1"})
    oldBuckets[1] = append(oldBuckets[1], KeyValue{Key: "key2", Value: "value2"})

    newBuckets := rehash(oldBuckets)
    fmt.Println("Rehashed table:", newBuckets)
}
```

---

### **Зачем нужен рехешинг?**

1. **Уменьшение коллизий:**
   - Увеличение размера массива уменьшает вероятность того, что несколько ключей попадут в одну и ту же ячейку.

2. **Повышение производительности:**
   - При большом коэффициенте заполнения (`loadFactor`) время поиска или вставки элементов увеличивается.
   - Рехешинг возвращает операции к их средней временной сложности `O(1)`.

3. **Когда делать рехешинг?**
   - Когда количество элементов в таблице превышает 75% её размера (`loadFactor > 0.75`).

---

### **Итог**

1. **`simpleHash`:**
   - Преобразует строку в индекс массива.
   - Простой и эффективный алгоритм с использованием умножения на 31.

2. **`rehash`:**
   - Перераспределяет элементы из старой таблицы в новую при увеличении её размера.
   - Уменьшает коллизии и поддерживает высокую производительность.

Если остались вопросы или что-то нужно разобрать подробнее — пиши! 😊